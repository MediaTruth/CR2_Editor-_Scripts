import numpy as np

def rgb_to_bayer_rggb(image_rgb):
    """
    Converts an RGB image (H, W, 3) to a single-channel Bayer CFA (H, W).
    Pattern: RGGB (Red, Green, Green, Blue). Note: The Original CR2Editor.Web.app uses a different script. App uses a multi-step script and a single script variant to make CR2s from aany image
    """
    height, width, _ = image_rgb.shape
    
    # Create an empty single-channel array for the raw sensor data
    cfa = np.zeros((height, width), dtype=image_rgb.dtype)

    # ---------------------------------------------------------
    # The Bayer Pattern Logic (RGGB)
    # R G
    # G B
    # ---------------------------------------------------------

    # 1. Red Pixel: Row Even, Col Even (0,0), (0,2), (2,0)...
    # Take the Red channel (index 0)
    cfa[0::2, 0::2] = image_rgb[0::2, 0::2, 0]

    # 2. Green Pixel (Row 0): Row Even, Col Odd (0,1), (0,3)...
    # Take the Green channel (index 1)
    cfa[0::2, 1::2] = image_rgb[0::2, 1::2, 1]

    # 3. Green Pixel (Row 1): Row Odd, Col Even (1,0), (1,2)...
    # Take the Green channel (index 1)
    cfa[1::2, 0::2] = image_rgb[1::2, 0::2, 1]

    # 4. Blue Pixel: Row Odd, Col Odd (1,1), (1,3)...
    # Take the Blue channel (index 2)
    cfa[1::2, 1::2] = image_rgb[1::2, 1::2, 2]

    return cfa

# --- Example Usage ---
# Create a dummy 4x4 RGB image (pure red, pure green, etc.)
# In a real workflow, this would be your linearized image data.
dummy_img = np.random.randint(0, 255, (4, 4, 3), dtype=np.uint8)

# Convert to Bayer CFA
raw_sensor_data = rgb_to_bayer_rggb(dummy_img)

print("Original RGB Shape:", dummy_img.shape)
print("Bayer CFA Shape:   ", raw_sensor_data.shape)
print("\nSample Bayer Data (Top Left 2x2):\n", raw_sensor_data[:2, :2])
